# Tutorial: Integraci√≥n REST API con WebSocket en NestJS

## üìã Tabla de Contenidos

1. [Introducci√≥n](#introducci√≥n)
2. [Arquitectura del Sistema](#arquitectura-del-sistema)
3. [Requisitos Previos](#requisitos-previos)
4. [Proyecto 1: API REST](#proyecto-1-api-rest)
5. [Proyecto 2: Servidor WebSocket](#proyecto-2-servidor-websocket)
6. [Flujo de Comunicaci√≥n](#flujo-de-comunicaci√≥n)
7. [C√≥digo Clave Explicado](#c√≥digo-clave-explicado)
8. [Ejecuci√≥n de los Proyectos](#ejecuci√≥n-de-los-proyectos)
9. [Conceptos Clave](#conceptos-clave)

---

## Introducci√≥n

Este proyecto demuestra c√≥mo integrar una **API REST** con un **Servidor WebSocket** usando NestJS. El objetivo es crear un sistema donde los cambios realizados a trav√©s de la API REST se notifiquen en tiempo real a todos los clientes conectados mediante WebSockets.

### ¬øQu√© aprender√°s?

- Crear una API REST completa con operaciones CRUD
- Implementar un servidor WebSocket con NestJS
- Conectar ambos servicios mediante webhooks
- Enviar notificaciones en tiempo real a m√∫ltiples clientes
- Entender la diferencia entre comunicaci√≥n REST y WebSocket

---

## Arquitectura del Sistema

El sistema est√° compuesto por dos proyectos independientes que se comunican entre s√≠:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      HTTP POST        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Cliente   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> ‚îÇ   REST API   ‚îÇ
‚îÇ  (Postman)  ‚îÇ                       ‚îÇ  (Puerto     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ   3000)      ‚îÇ
                                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                             ‚îÇ
                                             ‚îÇ Webhook
                                             ‚îÇ HTTP POST
                                             ‚ñº
                                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                      ‚îÇ  WebSocket   ‚îÇ
                                      ‚îÇ   Server     ‚îÇ
                                      ‚îÇ  (Puerto     ‚îÇ
                                      ‚îÇ   3001)      ‚îÇ
                                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                             ‚îÇ
                                             ‚îÇ WebSocket
                                             ‚îÇ Broadcast
                                             ‚ñº
                              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                              ‚îÇ  Clientes WebSocket      ‚îÇ
                              ‚îÇ  (Navegador, Apps)       ‚îÇ
                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Roles de cada proyecto:

1. **REST API (rest/)**: API tradicional que maneja las operaciones CRUD sobre mascotas. Cuando se crea una mascota, env√≠a un webhook al servidor WebSocket.

2. **WebSocket Server (ws/)**: Servidor que mantiene conexiones persistentes con clientes y recibe webhooks de la API REST para retransmitir eventos a todos los clientes conectados.

---

## Requisitos Previos

Antes de comenzar, aseg√∫rate de tener instalado:

- **Node.js** (versi√≥n 18 o superior)
- **npm** (viene con Node.js)
- **NestJS CLI** instalado globalmente

Para instalar NestJS CLI globalmente:

```bash
npm install -g @nestjs/cli
```

### Conocimientos recomendados:

- Fundamentos de TypeScript
- Conceptos b√°sicos de NestJS (m√≥dulos, controladores, servicios)
- Conocimiento b√°sico de HTTP y APIs REST
- (Opcional) Familiaridad con Socket.io

---

## Proyecto 1: API REST

Este proyecto es una API REST tradicional que gestiona un cat√°logo de mascotas. La caracter√≠stica especial es que cuando se crea una mascota, env√≠a una notificaci√≥n al servidor WebSocket.

### Paso 1: Crear el proyecto NestJS

Abre tu terminal en la carpeta donde deseas crear los proyectos y ejecuta:

```bash
nest new rest
```

Durante la instalaci√≥n, selecciona tu gestor de paquetes preferido (npm, yarn, pnpm). Para este tutorial usaremos **npm**.

### Paso 2: Instalar dependencias necesarias

Navega al directorio del proyecto:

```bash
cd rest
```

Instala las dependencias para realizar peticiones HTTP:

```bash
npm install @nestjs/axios axios
```

**¬øPor qu√© estas dependencias?**
- `@nestjs/axios`: M√≥dulo de NestJS que envuelve Axios para hacer peticiones HTTP
- `axios`: Cliente HTTP popular para Node.js

### Paso 3: Generar el recurso de Mascotas

NestJS CLI puede generar toda la estructura CRUD autom√°ticamente:

```bash
nest generate resource mascotas
```

Te preguntar√°:
- **¬øQu√© capa de transporte prefieres?** Selecciona `REST API`
- **¬øGenerar puntos de entrada CRUD?** Selecciona `Yes`

Esto generar√°:
- `mascotas/mascotas.controller.ts` - Controlador con endpoints
- `mascotas/mascotas.service.ts` - L√≥gica de negocio
- `mascotas/mascotas.module.ts` - M√≥dulo de NestJS
- `mascotas/entities/mascota.entity.ts` - Entidad
- `mascotas/dto/create-mascota.dto.ts` - DTO para crear
- `mascotas/dto/update-mascota.dto.ts` - DTO para actualizar

### Paso 4: Definir la entidad Mascota

Abre el archivo `src/mascotas/entities/mascota.entity.ts` y reemplaza su contenido:

```typescript
export class Mascota {
    id: number;
    nombre: string;
    tipo: string;
}
```

**Explicaci√≥n:**
- `id`: Identificador √∫nico de la mascota
- `nombre`: Nombre de la mascota (ej: "Fido", "Michi")
- `tipo`: Tipo de mascota (ej: "Perro", "Gato", "Pez")

### Paso 5: Crear los DTOs

#### CreateMascotaDto

Abre `src/mascotas/dto/create-mascota.dto.ts`:

```typescript
export class CreateMascotaDto {
    nombre: string;
    tipo: string;
}
```

**¬øQu√© es un DTO?**
Data Transfer Object - define la estructura de datos que esperamos recibir en las peticiones.

#### UpdateMascotaDto

El archivo `update-mascota.dto.ts` ya viene configurado correctamente usando `PartialType`:

```typescript
import { PartialType } from '@nestjs/mapped-types';
import { CreateMascotaDto } from './create-mascota.dto';

export class UpdateMascotaDto extends PartialType(CreateMascotaDto) {}
```

Esto hace que todas las propiedades sean opcionales para actualizaciones.

### Paso 6: Implementar el servicio

Abre `src/mascotas/mascotas.service.ts` e implementa la l√≥gica con un array en memoria:

```typescript
import { Injectable } from '@nestjs/common';
import { CreateMascotaDto } from './dto/create-mascota.dto';
import { UpdateMascotaDto } from './dto/update-mascota.dto';
import { Mascota } from './entities/mascota.entity';

const mascotas: Mascota[] = [
  { id: 1, nombre: "Fido", tipo: "Perro" },
  { id: 2, nombre: "Michi", tipo: "Gato" },
  { id: 3, nombre: "Nemo", tipo: "Pez" }
]

@Injectable()
export class MascotasService {
  create(createMascotaDto: CreateMascotaDto) {
    const newMascota = { id: mascotas.length + 1, ...createMascotaDto };
    mascotas.push(newMascota);
    return newMascota;
  }

  findAll(): Mascota[] {
    return mascotas;
  }

  findOne(id: number): Mascota {
    const mascotaEncontrada = mascotas.find(mascota => mascota.id === id);
    if (!mascotaEncontrada) {
      throw new Error(`Mascota con id ${id} no encontrada`);
    }
    return mascotaEncontrada;
  }

  update(id: number, updateMascotaDto: UpdateMascotaDto) {
    const indice = mascotas.findIndex(mascota => mascota.id === id);
    if (indice === -1) {
      throw new Error(`Mascota con id ${id} no encontrada`);
    }
    const mascotaActualizada = { ...mascotas[indice], ...updateMascotaDto };
    mascotas[indice] = mascotaActualizada;
    return mascotaActualizada;
  }

  remove(id: number) {
    const indice = mascotas.findIndex(mascota => mascota.id === id);
    if (indice === -1) {
      throw new Error(`Mascota con id ${id} no encontrada`);
    }
    const mascotaEliminada = mascotas.splice(indice, 1);
    return mascotaEliminada[0];
  }
}
```

**Nota importante:** Usamos un array en memoria para simplicidad. En producci√≥n usar√≠as una base de datos.

### Paso 7: Configurar el m√≥dulo de Mascotas

Abre `src/mascotas/mascotas.module.ts` e importa el `HttpModule`:

```typescript
import { Module } from '@nestjs/common';
import { MascotasService } from './mascotas.service';
import { MascotasController } from './mascotas.controller';
import { HttpModule } from '@nestjs/axios';

@Module({
  imports: [HttpModule],
  controllers: [MascotasController],
  providers: [MascotasService],
})
export class MascotasModule {}
```

**¬øPor qu√© HttpModule?**
Lo necesitamos para hacer peticiones HTTP al servidor WebSocket desde el controlador.

### Paso 8: Implementar el controlador con webhook

Abre `src/mascotas/mascotas.controller.ts` y modifica el m√©todo `create` para enviar un webhook:

```typescript
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { MascotasService } from './mascotas.service';
import { CreateMascotaDto } from './dto/create-mascota.dto';
import { UpdateMascotaDto } from './dto/update-mascota.dto';
import { HttpService } from '@nestjs/axios';
import { firstValueFrom } from 'rxjs';

@Controller('mascotas')
export class MascotasController {
  constructor(
    private readonly httpService: HttpService,
    private readonly mascotasService: MascotasService
  ) {}

  @Post()
  async create(@Body() createMascotaDto: CreateMascotaDto) {
    const mascotaCreada = this.mascotasService.create(createMascotaDto);
    
    // Enviar webhook al servidor WebSocket
    try {
      await firstValueFrom(
        this.httpService.post(
          'http://localhost:3001/notificaciones/mascota-creada',
          mascotaCreada
        )
      );
      console.log('‚úÖ Notificaci√≥n enviada al WebSocket');
    } catch (error) {
      console.log('‚ö†Ô∏è WebSocket no disponible:', error.message);
    }
    
    return mascotaCreada;
  }

  @Get()
  findAll() {
    return this.mascotasService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.mascotasService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateMascotaDto: UpdateMascotaDto) {
    return this.mascotasService.update(+id, updateMascotaDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.mascotasService.remove(+id);
  }
}
```

**Puntos clave:**
- Inyectamos `HttpService` en el constructor
- Usamos `firstValueFrom()` para convertir el Observable de RxJS a Promise
- El webhook se env√≠a a `http://localhost:3001/notificaciones/mascota-creada`
- Usamos try-catch para que la API funcione incluso si el WebSocket no est√° disponible

### Paso 9: Configurar el archivo main.ts

Abre `src/main.ts` y configura CORS y el prefijo global:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  app.setGlobalPrefix('api');
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```

**¬øQu√© hace cada l√≠nea?**
- `app.enableCors()`: Habilita CORS para permitir peticiones desde otros dominios
- `app.setGlobalPrefix('api')`: Todos los endpoints tendr√°n el prefijo `/api`
- Puerto 3000: La API escuchar√° en `http://localhost:3000`

### Paso 10: Verificar el m√≥dulo principal

Abre `src/app.module.ts` y verifica que el m√≥dulo de Mascotas est√© importado:

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { MascotasModule } from './mascotas/mascotas.module';

@Module({
  imports: [MascotasModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

¬°Proyecto REST completado! Ahora los endpoints disponibles son:
- `POST /api/mascotas` - Crear mascota (env√≠a webhook)
- `GET /api/mascotas` - Listar todas
- `GET /api/mascotas/:id` - Obtener una
- `PATCH /api/mascotas/:id` - Actualizar
- `DELETE /api/mascotas/:id` - Eliminar

---

## Proyecto 2: Servidor WebSocket

Este proyecto act√∫a como intermediario: recibe webhooks de la API REST y los retransmite a todos los clientes conectados mediante WebSocket.

### Paso 1: Crear el proyecto NestJS

Regresa a la carpeta padre (donde est√° el proyecto `rest`) y crea el nuevo proyecto:

```bash
cd ..
nest new ws
```

Selecciona npm como gestor de paquetes.

### Paso 2: Instalar dependencias de WebSocket

Navega al proyecto:

```bash
cd ws
```

Instala las dependencias necesarias para WebSockets:

```bash
npm install @nestjs/websockets @nestjs/platform-socket.io
```

**¬øQu√© instalamos?**
- `@nestjs/websockets`: M√≥dulo de NestJS para WebSockets
- `@nestjs/platform-socket.io`: Adaptador para usar Socket.io (librer√≠a popular de WebSockets)

### Paso 3: Generar el recurso de Mascotas

Usamos el generador de recursos de NestJS, pero esta vez **sin generar los endpoints CRUD**:

```bash
nest generate resource mascotas
```

Te preguntar√°:
- **¬øQu√© capa de transporte prefieres?** Selecciona `WebSockets`
- **¬øGenerar puntos de entrada CRUD?** Selecciona `No`

Esto generar√°:
- `mascotas/mascotas.gateway.ts` - Gateway de WebSocket (en lugar de controlador)
- `mascotas/mascotas.service.ts` - Servicio
- `mascotas/mascotas.module.ts` - M√≥dulo de NestJS

**Nota:** A diferencia del proyecto REST, aqu√≠ NO generamos CRUD porque el WebSocket Server solo recibir√° webhooks y emitir√° eventos, no manejar√° operaciones CRUD directamente.

### Paso 4: Implementar el Gateway de WebSocket

Abre `src/mascotas/mascotas.gateway.ts` y crea el gateway:

```typescript
import {
  WebSocketGateway,
  OnGatewayConnection,
  OnGatewayDisconnect,
  WebSocketServer,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

@WebSocketGateway({ 
  cors: { origin: '*' } 
})
export class MascotasGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  handleConnection(client: Socket) {
    console.log('Cliente conectado:', client.id);
  }

  handleDisconnect(client: Socket) {
    console.log('Cliente desconectado:', client.id);
  }

  emitirEvento(evento: string, mensaje: any) {
    console.log('Emitiendo evento:', evento, 'con mensaje:', mensaje);
    this.server.emit(evento, mensaje);
  }
}
```

**Explicaci√≥n detallada:**

- `@WebSocketGateway()`: Decorador que convierte la clase en un gateway de WebSocket
- `cors: { origin: '*' }`: Permite conexiones desde cualquier origen (en producci√≥n, especifica dominios permitidos)
- `@WebSocketServer()`: Inyecta la instancia del servidor Socket.io
- `OnGatewayConnection`: Interface que obliga a implementar `handleConnection`
- `OnGatewayDisconnect`: Interface que obliga a implementar `handleDisconnect`
- `handleConnection()`: Se ejecuta cuando un cliente se conecta
- `handleDisconnect()`: Se ejecuta cuando un cliente se desconecta
- `emitirEvento()`: M√©todo personalizado para enviar eventos a TODOS los clientes conectados

### Paso 5: Configurar el m√≥dulo de Mascotas

Abre `src/mascotas/mascotas.module.ts` y exporta el gateway:

```typescript
import { Module } from '@nestjs/common';
import { MascotasService } from './mascotas.service';
import { MascotasGateway } from './mascotas.gateway';

@Module({
  providers: [MascotasGateway, MascotasService],
  exports: [MascotasGateway],
})
export class MascotasModule {}
```

**¬øPor qu√© exportamos el Gateway?**
Porque necesitamos usarlo desde el m√≥dulo de Notificaciones para emitir eventos cuando recibamos webhooks.

### Paso 6: Generar el recurso de Notificaciones

Este m√≥dulo recibir√° los webhooks de la API REST:

```bash
nest generate resource notificaciones
```

Te preguntar√°:
- **¬øQu√© capa de transporte prefieres?** Selecciona `REST API`
- **¬øGenerar puntos de entrada CRUD?** Selecciona `No`

Esto generar√°:
- `notificaciones/notificaciones.controller.ts` - Controlador REST
- `notificaciones/notificaciones.service.ts` - Servicio
- `notificaciones/notificaciones.module.ts` - M√≥dulo de NestJS

**Nota:** Aunque este es un servidor WebSocket, el m√≥dulo de notificaciones usa REST porque necesita recibir webhooks HTTP desde la API REST.

### Paso 7: Implementar el controlador de Notificaciones

Abre `src/notificaciones/notificaciones.controller.ts` y reemplaza su contenido:

```typescript
import { Body, Controller, Post } from '@nestjs/common';
import { NotificacionesService } from './notificaciones.service';
import { MascotasGateway } from 'src/mascotas/mascotas.gateway';

@Controller('notificaciones')
export class NotificacionesController {
  constructor(private readonly gateway: MascotasGateway) {}

  @Post('mascota-creada')
  crearMascota(@Body() body: any) {
    // Recibimos el webhook y lo retransmitimos por WebSocket
    this.gateway.emitirEvento('mascota-creada', body);
  }
}
```

**Flujo del controlador:**
1. Recibe una petici√≥n POST en `/notificaciones/mascota-creada`
2. Obtiene los datos de la mascota del body
3. Usa el gateway para emitir el evento a todos los clientes WebSocket

### Paso 8: Configurar el m√≥dulo de Notificaciones

Abre `src/notificaciones/notificaciones.module.ts` e importa el m√≥dulo de Mascotas:

```typescript
import { Module } from '@nestjs/common';
import { NotificacionesService } from './notificaciones.service';
import { NotificacionesController } from './notificaciones.controller';
import { MascotasModule } from 'src/mascotas/mascotas.module';

@Module({
  imports: [MascotasModule],
  controllers: [NotificacionesController],
  providers: [NotificacionesService],
})
export class NotificacionesModule {}
```

**¬øPor qu√© importar MascotasModule?**
Para poder inyectar el `MascotasGateway` en el controlador de notificaciones.

### Paso 9: Configurar el archivo main.ts

Abre `src/main.ts`:

```typescript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  await app.listen(process.env.PORT ?? 3001);
  console.log('üöÄ Servidor en http://localhost:3001');
}
bootstrap();
```

**Nota:** Este servidor corre en el puerto **3001** (diferente del REST que usa 3000).

### Paso 10: Verificar el m√≥dulo principal

Abre `src/app.module.ts` y verifica que ambos m√≥dulos est√©n importados:

```typescript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { MascotasModule } from './mascotas/mascotas.module';
import { NotificacionesModule } from './notificaciones/notificaciones.module';

@Module({
  imports: [MascotasModule, NotificacionesModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

¬°Servidor WebSocket completado! Ahora tenemos:
- Gateway WebSocket en el puerto 3001
- Endpoint REST `/notificaciones/mascota-creada` para recibir webhooks
- Capacidad de emitir eventos a todos los clientes conectados

---

## Flujo de Comunicaci√≥n

Ahora que ambos proyectos est√°n creados, veamos c√≥mo se comunican paso a paso:

### Flujo completo:

```
1. Cliente ‚Üí REST API
   POST http://localhost:3000/api/mascotas
   Body: { "nombre": "Rex", "tipo": "Perro" }

2. REST API procesa la petici√≥n
   - MascotasService.create() agrega la mascota al array
   - Retorna: { "id": 4, "nombre": "Rex", "tipo": "Perro" }

3. REST API ‚Üí WebSocket Server (Webhook)
   POST http://localhost:3001/notificaciones/mascota-creada
   Body: { "id": 4, "nombre": "Rex", "tipo": "Perro" }

4. WebSocket Server recibe el webhook
   - NotificacionesController.crearMascota() recibe los datos
   - Llama a MascotasGateway.emitirEvento()

5. WebSocket Server ‚Üí Clientes WebSocket
   - server.emit('mascota-creada', { id: 4, nombre: "Rex", tipo: "Perro" })
   - TODOS los clientes conectados reciben el evento instant√°neamente

6. Clientes WebSocket manejan el evento
   - En navegadores, aplicaciones m√≥viles, etc.
   - Pueden mostrar notificaciones, actualizar UI, etc.
```

### Ventajas de esta arquitectura:

- **Desacoplamiento**: REST API y WebSocket Server son independientes
- **Escalabilidad**: Puedes escalar cada servicio por separado
- **Flexibilidad**: M√∫ltiples servicios pueden enviar webhooks al WebSocket Server
- **Tiempo real**: Los clientes reciben actualizaciones instant√°neas sin necesidad de hacer polling

---

## C√≥digo Clave Explicado

### 1. Configuraci√≥n del HttpModule en REST

En `rest/src/mascotas/mascotas.module.ts`:

```typescript
@Module({
  imports: [HttpModule],  // Permite hacer peticiones HTTP
  controllers: [MascotasController],
  providers: [MascotasService],
})
```

El `HttpModule` proporciona el `HttpService` que usamos en el controlador.

### 2. Uso de firstValueFrom

En `rest/src/mascotas/mascotas.controller.ts`:

```typescript
await firstValueFrom(
  this.httpService.post('http://localhost:3001/notificaciones/mascota-creada', mascotaCreada)
);
```

**¬øPor qu√© firstValueFrom?**
- `httpService.post()` retorna un Observable (RxJS)
- `firstValueFrom()` convierte el Observable a Promise
- Podemos usar `await` para esperar la respuesta del webhook

### 3. Configuraci√≥n del WebSocketGateway

En `ws/src/mascotas/mascotas.gateway.ts`:

```typescript
@WebSocketGateway({ 
  cors: { origin: '*' } 
})
```

**Opciones importantes:**
- `cors`: Configuraci√≥n de CORS para WebSocket
- `origin: '*'`: Permite cualquier origen (cuidado en producci√≥n)
- Puedes agregar `namespace`, `path`, `transports`, etc.

### 4. Decorador @WebSocketServer()

```typescript
@WebSocketServer()
server: Server;
```

**¬øQu√© hace?**
- Inyecta la instancia del servidor Socket.io
- Nos da acceso a m√©todos como `emit()`, `to()`, `in()`, etc.
- Es como el "broadcaster" que env√≠a mensajes a los clientes

### 5. M√©todo server.emit()

```typescript
this.server.emit(evento, mensaje);
```

**Comportamiento:**
- Env√≠a el evento a **TODOS** los clientes conectados
- Otros m√©todos √∫tiles:
  - `server.to(room).emit()` - Env√≠a solo a una sala espec√≠fica
  - `client.emit()` - Env√≠a solo a un cliente espec√≠fico
  - `client.broadcast.emit()` - Env√≠a a todos excepto al emisor

### 6. Inyecci√≥n del Gateway en el controlador

En `ws/src/notificaciones/notificaciones.controller.ts`:

```typescript
constructor(private readonly gateway: MascotasGateway) {}
```

**¬øC√≥mo funciona?**
1. `MascotasModule` exporta `MascotasGateway`
2. `NotificacionesModule` importa `MascotasModule`
3. NestJS inyecta autom√°ticamente el gateway en el controlador

Esto es **Inyecci√≥n de Dependencias**, un patr√≥n clave en NestJS.

### 7. Manejo de errores en el webhook

```typescript
try {
  await firstValueFrom(this.httpService.post(...));
  console.log('‚úÖ Notificaci√≥n enviada');
} catch (error) {
  console.log('‚ö†Ô∏è WebSocket no disponible:', error.message);
}
```

**¬øPor qu√© try-catch?**
- Si el WebSocket Server no est√° corriendo, la API REST seguir√° funcionando
- Los errores se registran pero no detienen la ejecuci√≥n
- Esto hace el sistema m√°s robusto

---

## Ejecuci√≥n de los Proyectos

### Orden de inicio

Es importante iniciar los proyectos en el orden correcto:

**1. Primero, inicia el Servidor WebSocket:**

```bash
cd ws
npm run start:dev
```

Deber√≠as ver:
```
üöÄ Servidor en http://localhost:3001
```

**2. Luego, inicia la API REST:**

Abre otra terminal:

```bash
cd rest
npm run start:dev
```

Deber√≠as ver:
```
[Nest] Application successfully started
```

### ¬øPor qu√© este orden?

Si inicias la API REST primero e intentas crear una mascota, el webhook fallar√° porque el servidor WebSocket no est√° escuchando. Aunque la API seguir√° funcionando gracias al try-catch, no se enviar√° la notificaci√≥n.

### Comandos √∫tiles

```bash
# Modo desarrollo (con hot-reload)
npm run start:dev

# Modo producci√≥n
npm run build
npm run start:prod

# Ver logs detallados
npm run start:dev -- --debug
```

### Verificar que todo funciona

1. **Verifica el REST API:**
   ```bash
   curl http://localhost:3000/api/mascotas
   ```

2. **Verifica el WebSocket Server:**
   - El servidor debe estar escuchando en el puerto 3001
   - Puedes conectarte con un cliente Socket.io

---

## Conceptos Clave

### 1. Diferencia entre REST y WebSocket

| Caracter√≠stica | REST API | WebSocket |
|---------------|----------|-----------|
| **Protocolo** | HTTP/HTTPS | WS/WSS |
| **Comunicaci√≥n** | Unidireccional (cliente ‚Üí servidor) | Bidireccional (cliente ‚Üî servidor) |
| **Conexi√≥n** | Sin estado, se cierra despu√©s de cada petici√≥n | Persistente, conexi√≥n abierta |
| **Uso t√≠pico** | CRUD, operaciones bajo demanda | Notificaciones en tiempo real, chat |
| **Overhead** | Mayor (headers HTTP en cada petici√≥n) | Menor (conexi√≥n persistente) |
| **Escala** | F√°cil de escalar (stateless) | M√°s complejo (conexiones persistentes) |

**Cu√°ndo usar cada uno:**
- **REST**: Operaciones CRUD, consultas, autenticaci√≥n
- **WebSocket**: Chat, notificaciones, actualizaciones en tiempo real, juegos multijugador

### 2. ¬øQu√© es un Webhook?

Un **webhook** es una petici√≥n HTTP que un sistema env√≠a a otro cuando ocurre un evento espec√≠fico.

**Caracter√≠sticas:**
- Es una forma de comunicaci√≥n "push" (el servidor env√≠a datos sin que se lo pidan)
- Normalmente es una petici√≥n POST con datos en JSON
- Permite integrar sistemas de manera desacoplada

**En nuestro proyecto:**
- La API REST env√≠a un webhook al WebSocket Server
- URL del webhook: `http://localhost:3001/notificaciones/mascota-creada`
- Payload: Los datos de la mascota creada

### 3. Patr√≥n Observer en WebSockets

WebSockets implementan el **patr√≥n Observer**:

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   Subject   ‚îÇ
                    ‚îÇ  (Gateway)  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ               ‚îÇ               ‚îÇ
           ‚ñº               ‚ñº               ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Observer ‚îÇ    ‚îÇ Observer ‚îÇ   ‚îÇ Observer ‚îÇ
    ‚îÇ Cliente1 ‚îÇ    ‚îÇ Cliente2 ‚îÇ   ‚îÇ Cliente3 ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**¬øC√≥mo funciona?**
1. Los clientes se "suscriben" al gateway (se conectan)
2. Cuando ocurre un evento, el gateway "notifica" a todos los observadores
3. Los clientes reciben el evento y reaccionan

### 4. Comunicaci√≥n Bidireccional vs Unidireccional

**Unidireccional (REST):**
```
Cliente ‚Üí Servidor: "Dame los datos"
Servidor ‚Üí Cliente: "Aqu√≠ est√°n"
[Conexi√≥n cerrada]
```

**Bidireccional (WebSocket):**
```
Cliente ‚Üí Servidor: [Conexi√≥n establecida]
Cliente ‚Üê Servidor: "Bienvenido"
Cliente ‚Üí Servidor: "Env√≠ame notificaciones"
Servidor ‚Üí Cliente: "Nueva mascota creada"
Servidor ‚Üí Cliente: "Usuario conectado"
Cliente ‚Üí Servidor: "Escribiendo mensaje..."
[Conexi√≥n permanece abierta]
```

### 5. Ventajas y Desventajas de WebSockets

**Ventajas:**
- ‚úÖ Latencia muy baja (milisegundos)
- ‚úÖ Menos overhead (sin headers HTTP repetidos)
- ‚úÖ Comunicaci√≥n bidireccional
- ‚úÖ Ideal para aplicaciones en tiempo real

**Desventajas:**
- ‚ùå M√°s complejo de implementar
- ‚ùå M√°s dif√≠cil de escalar (conexiones con estado)
- ‚ùå Requiere m√°s recursos del servidor
- ‚ùå Problemas con proxies y firewalls antiguos

### 6. ¬øPor qu√© separar REST y WebSocket?

**Razones arquitect√≥nicas:**

1. **Separaci√≥n de responsabilidades**
   - REST: Maneja operaciones CRUD y l√≥gica de negocio
   - WebSocket: Maneja comunicaci√≥n en tiempo real

2. **Escalabilidad**
   - Puedes escalar cada servicio independientemente
   - Ejemplo: 5 instancias REST, 2 instancias WebSocket

3. **Mantenibilidad**
   - Cada servicio tiene un prop√≥sito claro
   - M√°s f√°cil de testear y debuggear

4. **Flexibilidad**
   - M√∫ltiples servicios pueden usar el mismo WebSocket Server
   - El REST API puede funcionar sin WebSocket

---

## Resumen

Has aprendido a:

‚úÖ Crear una API REST completa con NestJS  
‚úÖ Implementar un servidor WebSocket con Socket.io  
‚úÖ Conectar ambos servicios mediante webhooks  
‚úÖ Enviar notificaciones en tiempo real a m√∫ltiples clientes  
‚úÖ Entender cu√°ndo usar REST vs WebSocket  
‚úÖ Aplicar el patr√≥n Observer en aplicaciones web  

### Pr√≥ximos pasos

Para profundizar m√°s, puedes:

1. **Agregar autenticaci√≥n**: Validar tokens JWT en el gateway
2. **Implementar salas (rooms)**: Notificar solo a grupos espec√≠ficos
3. **Persistencia**: Usar una base de datos real (PostgreSQL, MongoDB)
4. **Cliente web**: Crear una interfaz HTML/JS que se conecte al WebSocket
5. **Manejo de reconexiones**: Implementar l√≥gica para reconectar clientes
6. **Tests**: Escribir tests unitarios y e2e para ambos servicios

---

## Estructura Final del Proyecto

```
w5-ws/
‚îú‚îÄ‚îÄ rest/                          # API REST (Puerto 3000)
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mascotas/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-mascota.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ update-mascota.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mascota.entity.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mascotas.controller.ts    # Env√≠a webhook
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mascotas.service.ts       # CRUD en memoria
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mascotas.module.ts        # Importa HttpModule
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.ts                       # Puerto 3000, CORS, prefijo /api
‚îÇ   ‚îî‚îÄ‚îÄ package.json                      # @nestjs/axios, axios
‚îÇ
‚îî‚îÄ‚îÄ ws/                            # WebSocket Server (Puerto 3001)
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ mascotas/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mascotas.gateway.ts       # Gateway WebSocket
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mascotas.service.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mascotas.module.ts        # Exporta Gateway
    ‚îÇ   ‚îú‚îÄ‚îÄ notificaciones/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notificaciones.controller.ts  # Recibe webhook
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ notificaciones.service.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ notificaciones.module.ts      # Importa MascotasModule
    ‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ main.ts                       # Puerto 3001, CORS
    ‚îî‚îÄ‚îÄ package.json                      # @nestjs/websockets, socket.io
```

---

**¬°Felicidades!** üéâ Has completado el tutorial de integraci√≥n REST con WebSocket en NestJS.

